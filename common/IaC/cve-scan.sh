#!/bin/bash
#
# WARNING: Automatically copied from sts-tools
#
# Turn on errors.
set -e
# BASE_DIR is picked up from the location of this script.
BASE_DIR="$(cd -P "$(dirname "${BASH_SOURCE[0]}")" && pwd -P)"
cd "${BASE_DIR}"

ALLOW_FILE="cve-allow.json"
TMP_JSON=$(mktemp /tmp/cve_scan_XXXXXXXX)

while [[ $# -gt 0 ]]; do
  key="$1"

  case $key in
  --scan)
    shift # past argument
    cp "$1" "${TMP_JSON}"
    ;;
  --allow)
    shift # past argument
    ALLOW_FILE="$1"
    # shift
    ;;
  *)
    echo "Unknown option ${key}"
    exit 1
    ;;
  esac

  shift
done

if [[ ! -s ${ALLOW_FILE} ]]; then
  echo "CVE allow file not found ${ALLOW_FILE}"

  exit 1
fi

if [[ ! -s "${TMP_JSON}" ]]; then

  # COMMIT_ID is an environment variable that
  # gets set automatically by Jenkins when it
  # performs the build.
  if [[ -z "${GIT_COMMIT}" ]]; then
    echo "Must specify GIT_COMMIT"
    exit 1
  fi

  # Set environment variables needed to do our work.
  #
  . ./init.sh

  ECR="${ACCOUNT_ID}.dkr.ecr.${REGION}.amazonaws.com"

  aws --profile "${PROFILE}" ecr get-login-password | docker login --username AWS --password-stdin "${ECR}"

  # Image scan
  # Perform CVE scan and iterate until "COMPLETE" status is returned.
  SCAN_COMPLETE="INCOMPLETE"
  while [[ "${SCAN_COMPLETE}" != "COMPLETE" ]]; do
    aws --profile "${PROFILE}" ecr describe-image-scan-findings --repository-name "temp-${AREA,,}/${DOCKER_REPO}" --image-id "imageTag=git_${GIT_COMMIT}" >"${TMP_JSON}"
    SCAN_COMPLETE=$(jq -r .imageScanStatus.status "${TMP_JSON}")
    jq . ${TMP_JSON}
    sleep 1
  done

  # Copy TMP_JSON to a standard name/lcation so that it
  # can be stashed as an artifact by Jenkins.
  cp "${TMP_JSON}" "${WORKSPACE}/cve-scan.json"
fi

# Now that complete scan results are available, check for
# vulnerabilities and their levels of severity.  For now,
# we are failing if a non-null number of "HIGH" or "CRITICAL"
# severity counts is found.
highCounter=0
criticalCounter=0
skippedCounter=0

lines=$(jq --compact-output --raw-output '.imageScanFindings.findings[]' "${TMP_JSON}")
while read -r elm; do

  cve=$(jq -r '.name' <<<"${elm}")
  iceObj=$(jq -r ".\"${cve}\"//empty" "${ALLOW_FILE}")
  if [[ -n "${iceObj}" ]]; then
    iceUntil=$(jq -r ".until" <<<"${iceObj}")

    if [[ -n "${iceUntil}" ]]; then
      untilSeconds=$(date --date="${iceUntil}" +%s)
      nowSeconds=$(date +%s)
      set +e
      ((diff=nowSeconds-untilSeconds))
      set -e
      if [[ ${diff} -lt 0 ]]; then
        reason=$(jq -r ".reason" <<<"${iceObj}")
        echo "${cve} is on ice until ${iceUntil} because ${reason}"
        set +e
        ((skippedCounter++))
        set -e
        continue
      fi
    fi
  fi

  severity=$(jq -r '.severity' <<<"${elm}")

  if [[ "${severity}" == "HIGH" ]]; then
    set +e
    ((highCounter++))
    set -e
  elif [[ "${severity}" == "CRITICAL" ]]; then
    set +e
    ((criticalCounter++))
    set -e
  fi
done <<<"$lines"

if [[ ${highCounter} == 0 ]] && [[ ${criticalCounter} == 0 ]]; then
  # Passed scan.
  echo "CVE scan detected no HIGH/CRITICAL severity vulnerabilities. Skipped: ${skippedCounter}"

  echo "Passed CVE scan."
  # Clean up.
  rm -f "${TMP_JSON}"
  exit 0
else
  # Failed scan.
  echo "CVE scan detected one or more HIGH(${highCounter}) or CRITICAL(${criticalCounter}) CVEs. Skipped: ${skippedCounter}"
  echo "Failed CVE scan."
  # Clean up.
  rm -f "${TMP_JSON}"
  exit 1
fi
