#!/bin/bash
#
# WARNING: Automatically copied from dga-tools
#
# Turn on errors.
set -e
# BASE_DIR is picked up from the location of this script.
BASE_DIR="$(cd -P "$(dirname "$BASH_SOURCE")" && pwd -P)"
cd "${BASE_DIR}"
ALLOW_FILE="cve-allow.json"
TMP_JSON=$(mktemp /tmp/cve_scan_XXXXXX.json)

while [[ $# -gt 0 ]]; do
  key="$1"

  case $key in
  --scan)
    shift # past argument
    cp "$1" ${TMP_JSON}
    ;;
  --allow)
    shift # past argument
    ALLOW_FILE="$1"
    # shift
    ;;
  *)
    echo "Unknown option ${key}"
    exit 1
    ;;
  esac

  shift
done

if [[ ! -s ${ALLOW_FILE} ]]; then
  echo "CVE allow file not found ${ALLOW_FILE}"
  pwd
  ls -l 

  exit 1
fi 

if [[ ! -s "${TMP_JSON}" ]]; then

  # COMMIT_ID is an environment variable that
  # gets set automatically by Jenkins when it
  # performs the build.
  if [[ -z "${GIT_COMMIT}" ]]; then
    echo "Must specify GIT_COMMIT"
    exit 1
  fi

  # Set environment variables needed to do our work.
  #
  . ./init.sh

  ECR="${ACCOUNT_ID}.dkr.ecr.${REGION}.amazonaws.com"

  aws ecr get-login-password | docker login --username AWS --password-stdin ${ECR}

  # Image scan
  # Perform CVE scan and iterate until "COMPLETE" status is returned.
  SCAN_COMPLETE="INCOMPLETE"
  while [[ "${SCAN_COMPLETE}" != "COMPLETE" ]]; do
    aws ecr describe-image-scan-findings --repository-name temp-${AREA,,}/${DOCKER_REPO} --image-id "imageTag=git_${GIT_COMMIT}" >${TMP_JSON}
    SCAN_COMPLETE=$(jq -r .imageScanStatus.status ${TMP_JSON})
    sleep 1
  done

  # Copy TMP_JSON to a standard name/lcation so that it
  # can be stashed as an artifact by Jenkins.
  cp ${TMP_JSON} ${WORKSPACE}/cve-scan.json
fi 

# Now that complete scan results are available, check for
# vulnerabilities and their levels of severity.  For now,
# we are failing if a non-null number of "HIGH" or "CRITICAL"
# severity counts is found.
set +e
let highCounter=0
let criticalCounter=0
for elm in `jq -c .imageScanFindings.findings[] ${TMP_JSON}`;do 
  
  cve=$(jq -r '.name' <<< "${elm}")
  iceObj=$(jq -r ".\"${cve}\"//empty" ${ALLOW_FILE})
  if [[ ! -z "${iceObj}" ]]; then
    iceUntil=$(jq -r ".until" <<< "${iceObj}")

    if [[ ! -z "${iceUntil}" ]]; then
      untilSeconds=$(date --date="${iceUntil}" +%s)
      nowSeconds=$(date +%s)

      let diff=${nowSeconds}-${untilSeconds}
      if [[ ${diff} -lt 0 ]]; then
        reason=$(jq -r ".reason" <<< "${iceObj}")
        echo "${cve} is on ice until ${iceUntil} because ${reason}"
        continue
      fi
    fi
  fi

  severity=$(jq -r '.severity' <<< "${elm}")

  if [[ "${severity}" == "HIGH" ]]; then
    let highCounter++
  elif [[ "${severity}" == "CRITICAL" ]]; then
    let criticalCounter++
  fi
done

if [[ ${highCounter} == 0 ]] && [[ ${criticalCounter} == 0 ]]; then
  # Passed scan.
  echo "CVE scan detected no HIGH/CRITICAL severity vulnerabilities."
  echo "Passed CVE scan."
  # Clean up.
  rm -f ${TMP_JSON}
  exit 0
else
  # Failed scan.
  echo "CVE scan detected one or more HIGH(${highCounter}) or CRITICAL(${criticalCounter}) CVEs."
  echo "Failed CVE scan."
  # Clean up.
  rm -f ${TMP_JSON}
  exit 1
fi
